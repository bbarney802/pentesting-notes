# Burp Suite Repeater

Repeater - In short: Burp Suite Repeater allows us to craft and/or relay intercepted requests to a target at will. In layman's terms, it means we can take a request captured in the Proxy, edit it, and send the same request repeatedly as many times as we wish. Alternatively, we could craft requests by hand, much as we would from the CLI (Command Line Interface), using a tool such as cURL to build and send requests.

This ability to edit and resend the same request multiple times makes Repeater ideal for any kind of manual poking around at an endpoint, providing us with a nice Graphical User Interface (GUI) for writing the request payload and numerous views (including a rendering engine for a graphical view) of the response so that we can see the results of our handiwork in action.

The Repeater interface can be split into six main sections -- an annotated diagram can be found below the following bullet points:

1-At the very top left of the tab, we have a list of Repeater requests. We can have many different requests going through Repeater: each time we send a new request to Repeater, it will appear up here.

2-Directly underneath the request list, we have the controls for the current request. These allow us to send a request, cancel a hanging request, and go forwards/backwards in the request history.

3-Still on the left-hand side of the tab, but taking up most of the window, we have the request and response view. We edit the request in the Request view then press send. The response will show up in the Response view.

4-Above the request/response section, on the right-hand side, is a set of options allowing us to change the layout for the request and response views. By default, this is usually side-by-side (horizontal layout, as in the screenshot); however, we can also choose to put them above/below each other (vertical layout) or in separate tabs (combined view).

5-At the right-hand side of the window, we have the Inspector, which allows us to break requests apart to analyze and edit them in a slightly more intuitive way than with the raw editor. We will cover this in a later task.

6-Finally, above the Inspector we have our target. Quite simply, this is the IP address or domain to which we are sending requests. When we send requests to Repeater from other parts of Burp Suite, this will be filled in automatically.

### Basic usage

Best to capture requests in the proxy then send that through the Repeater for editing and resending

Right click the captured request in proxy and then choose send to repeater. Then we will see the request available

The Target and inspector elements are now also showing info but we donâ€™t have a response yet so that is blank.

When we click the Send button the Response section populates.

To change things just type right in the request window and press send again

Example changing the connection header to open instead of close

This would result in a connection header with a value of keep-alive

WE can also use the history to go forwards and backwards in our modification history

### Repeater Views

We have four display options here:

Pretty: This is the default option. It takes the raw response and attempts to beautify it slightly, making it easier to read.

Raw: The pure, un-beautified response from the server.

Hex: This view takes the raw response and gives us a byte view of it -- especially useful if the response is a binary file.

Render: The render view renders the page as it would appear in your browser. Whilst not hugely useful given that we would usually be interested in the source code when using Repeater, this is still a neat trick.

In most instances, the "Pretty" option is perfectly adequate; however, it is still well worth knowing how to use the other three options.

### Repeater Inspector

Inspector is entirely supplementary to the request and response fields of the Repeater window. If you understand how to read and edit HTTP requests, then you may find that you rarely use Inspector at all.

That said, it is a superb way to get a prettified breakdown of the requests and responses, as well as for experimenting to see how changes made using the higher-level Inspector affect the equivalent raw versions.

Inspector can be used in the Proxy as well as Repeater. In both cases, it appears over at the very right hand side of the window and gives us a list of the components in the request and response:

Of these, the request sections can nearly always be altered, allowing us to add, edit, and delete items. For example, in the Request Attributes section, we can edit the parts of the request that deal with location, method and protocol; e.g. changing the resource we are looking to retrieve, altering the request from GET to another HTTP method, or switching protocol from HTTP/1 to HTTP/2:

The other sections available for viewing and/or editing are:

Query Parameters, which refer to data being sent to the server in the URL. For example, in a GET request to https://admin.tryhackme.com/?redirect=false, there is a query parameter called "redirect" with a value of "false".

Body Parameters, which do the same thing as Query Parameters, but for POST requests. Anything that we send as data in a POST request will show up in this section, once again allowing us to modify the parameters before re-sending.

Request Cookies contain, as you may expect, a modifiable list of the cookies which are being sent with each request.

Request Headers allow us to view, access, and modify (including outright adding or removing) any of the headers being sent with our requests. Editing these can be very useful when attempting to see how a webserver will respond to unexpected headers.

Response Headers show us the headers that the server sent back in response to our request. These cannot be edited (as we can't control what headers the server returns to us!). Note that this section will only show up after we have sent the request and received a response.

These components can all be found as text within the request and response sections; however, it can be nice to see them in the tabular format offered by Inspector. It is well worth adding, removing, and editing headers in Inspector to get a feel for how the raw version changes as you do so.

### Practical Example

Used when we want to send multiple requests numerous times usually with small changes in between requests

For example, we may wish to manually test for an SQL Injection vulnerability (which we will do in an upcoming task), attempt to bypass a web application firewall filter, or simply add or change parameters in a form submission.

For this example we want to alter the headers of a request we send to a target

[http://10.10.87.44/](http://10.10.87.44/)

get it in the proxy and send it to the repeater

send it one time from the repeater and now we have the source code in the response tab

use inspector to add a header called FlagAuthorised and set it to have a value of True.

Then send it from repeater and the response is the flag

### Practical Challenge

In the previous task, we used Repeater to add a header and send a request; this should serve as an example for using Repeater -- now it's time for a very simple challenge!

With your proxy deactivated, head over to [http://10.10.87.44/products/](http://10.10.87.44/products/) and try clicking on some of the "See More" links.

Do you notice that it redirects you to a numeric endpoint (e.g. /products/3) when you click for more details?

This endpoint needs to be validated to ensure that the number you try to navigate to exists and is a valid integer; however, what happens if it is not adequately validated?

I tried [http://10.10.87.44/products/-2](http://10.10.87.44/products/-2)

I did this in inspector in the GET path

This gave me the 500 Internal Server Error

In the response source code I see the flag

### Extra Mile SQLi with repeater

This task contains an extra-mile challenge, which means that it is a slightly harder, real-world application for Burp Repeater. If you feel comfortable performing a manual SQL Injection by yourself, you may skip to the last question and try this as a blind challenge; otherwise a guide will be given below.

The brief is as follows:

There is a Union SQL Injection vulnerability in the ID parameter of the /about/ID endpoint. Find this vulnerability and execute an attack to retrieve the notes about the CEO stored in the database.

We know that there is a vulnerability, and we know where it is. Now we just need to exploit it!

Let's start by capturing a request to http://10.10.87.44/about/2 in the Burp Proxy. Once you have captured the request, send it to Repeater

Now that we have our request primed, let's confirm that a vulnerability exists. Adding a single apostrophe (') is usually enough to cause the server to error when a simple SQLi is present, so, either using Inspector or by editing the request path manually, add an apostrophe after the "2" at the end of the path and send the request:

You should see that the server responds with a "500 Internal Server Error", indicating that we successfully broke the query:

If we look through the body of the server's response, we see something very interesting at around line 40. The server is telling us the query we tried to execute:

Invalid statement: SELECT firstName, lastName, pfpLink, role, bio FROM people WHERE id = 2'

This is an extremely useful error message which the server should absolutely not be sending us, but the fact that we have it makes our job significantly more straightforward.

The message tells us a couple of things that will be invaluable when exploiting this vulnerability:

The database table we are selecting from is called people.

The query is selecting five columns from the table: firstName, lastName, pfpLink, role, and bio. We can guess where these fit into the page, which will be helpful for when we choose where to place our responses.

With this information, we can skip over the query column number and table name enumeration steps.

Although we have managed to cut out a lot of the enumeration required here, we still need to find the name of our target column.

As we know the table name and the number of rows, we can use a union query to select the column names for the people table from the columns table in the information\_schema default database.

A simple query for this is as follows:

/about/0 UNION ALL SELECT column\_name,null,null,null,null FROM information\_schema.columns WHERE table\_name="people"

This creates a union query and selects our target then four null columns (to avoid the query erroring out). Notice that we also changed the ID that we are selecting from 2 to 0. By setting the ID to an invalid number, we ensure that we don't retrieve anything with the original (legitimate) query; this means that the first row returned from the database will be our desired response from the injected query.

Looking through the returned response, we can see that the first column name (id) has been inserted into the page title:

We have successfully pulled the first column name out of the database, but we now have a problem. The page is only displaying the first matching item -- we need to see all of the matching items.

Fortunately, we can use our SQLi to group the results. We can still only retrieve one result at a time, but by using the group\_concat() function, we can amalgamate all of the column names into a single output:

/about/0 UNION ALL SELECT group\_concat(column\_name),null,null,null,null FROM information\_schema.columns WHERE table\_name="people"

The query gave us 8 columns now

About | id,firstName,lastName,pfpLink,role,shortRole,bio,notes None

Considering our task, it seems a safe bet that our target column is notes

Finally, we are ready to take the flag from this database -- we have all of the information that we need:

The name of the table: people.

The name of the target column: notes.

The ID of the CEO is 1; this can be found simply by clicking on Jameson Wolfe's profile on the /about/ page and checking the ID in the URL.

Let's craft a query to extract this flag:

0 UNION ALL SELECT notes,null,null,null,null FROM people WHERE id = 1

That got us the flag woot woot
